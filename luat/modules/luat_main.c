

#include "luat_base.h"
#include "luat_malloc.h"
//#include "luat_fs.h"
#include "luat_log.h"
#include "stdio.h"
#include "luat_msgbus.h"

static lua_State *L;

lua_State * luat_get_state() {
  return L;
}

static void print_list_mem(const char* name) {
  luat_printf("==openlib name=%s\n", name);
  list_mem();
}

static void luat_openlibs(lua_State *L) {
    // 初始化队列服务
    luat_msgbus_init();
    print_list_mem("done>luat_msgbus_init");

    luaL_requiref(L, "rtos", luaopen_rtos, 1);
    lua_pop(L, 1);
    print_list_mem("done> require(rtos)");

    //luaL_requiref(L, "sys", luaopen_sys, 1);
    //lua_pop(L, 1);
    //print_list_mem("done> require(sys)");
    
    luaL_requiref(L, "timer", luaopen_timer, 1);
    lua_pop(L, 1);
    print_list_mem("done> require(timer)");

    //#ifdef RT_USING_PIN
    luaL_requiref(L, "gpio", luaopen_gpio, 1);
    lua_pop(L, 1);
    print_list_mem("done> require(gpio)");
    //#endif

    luaL_requiref(L, "wlan", luaopen_wlan, 1);
    lua_pop(L, 1);
    print_list_mem("done> require(wlan)");

    luaL_requiref(L, "socket", luaopen_socket, 1);
    lua_pop(L, 1);
    print_list_mem("done> require(socket)");
    
    luaL_requiref(L, "sensor", luaopen_sensor, 1);
    lua_pop(L, 1);
    print_list_mem("done> require(sensor)");
}

static int test_load_fs() {
  return luaL_dofile(L, "/main.lua");
}

static int pmain(lua_State *L) {
    int re = 0;
    
    print_list_mem("begin> luaL_openlibs");
    luaL_openlibs(L);
    print_list_mem("done > luaL_openlibs");

    // 加载本地库
    print_list_mem("begin> luat_openlibs");
    luat_openlibs(L);
    print_list_mem("begin> luat_openlibs");
    
    // 测试代码
    // re = test_core_simple();
    // re = test_gpio_simple();
    // re = test_gpio_led();
    // re = test_timer_simple();
    // re = test_io_simple();
    re = test_load_fs();

    if (re) {
        //luat_print("luaL_dostring  return re != 0\n");
        luat_print(lua_tostring(L, -1));
    }
    lua_pushboolean(L, 1);  /* signal no errors */
    return 1;
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}


/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message("LUAT", msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

static int panic (lua_State *L) {
  lua_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
                        lua_tostring(L, -1));
  return 0;  /* return to Lua to abort */
}

int luat_main (int argc, char **argv, int _) {
  list_mem();
  luat_print("=================================call luat_main\n");
  // 1. init filesystem
  luat_fs_init();
  list_mem();
  luat_print("=================================after luat_fs_init\n");

  // 2. init Lua State
  int status, result;
  L = lua_newstate(luat_heap_alloc, NULL);
  if (L == NULL) {
    l_message(argv[0], "cannot create state: not enough memory\n");
    return 1;
  }
  if (L) lua_atpanic(L, &panic);
  list_mem();
  luat_print("=================================after lua_newstate\n");
  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
  lua_pushinteger(L, argc);  /* 1st argument */
  lua_pushlightuserdata(L, argv); /* 2nd argument */
  status = lua_pcall(L, 2, 1, 0);  /* do the call */
  result = lua_toboolean(L, -1);  /* get result */
  report(L, status);
  //lua_close(L);
  return (result && status == LUA_OK) ? 0 : 2;
}
