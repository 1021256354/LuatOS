

#include "luat_base.h"
#include "luat_malloc.h"
//#include "luat_fs.h"
#include "luat_log.h"

static void luat_openlibs(lua_State *L) {
    luaL_requiref(L, "msgbus", luaopen_msgbus, 1);
    lua_pop(L, 1);

    luaL_requiref(L, "sys", luaopen_sys, 1);
    lua_pop(L, 1);
    
    luaL_requiref(L, "timer", luaopen_timer, 1);
    lua_pop(L, 1);
    
    luaL_requiref(L, "gpio", luaopen_gpio, 1);
    lua_pop(L, 1);
}

static int pmain(lua_State *L) {
    int re = 0;
    //luat_print("luat_pmain!!!\n");
    // 加载系统库
    luaL_openlibs(L);

    // 加载本地库
    //luat_openlibs(L);

    // 打印个提示
    //luat_print("luat_boot_complete\n");

    // 执行
    //lfs_file_t file;
    //if (LFS_FileOpen(&file, "/lua/main.lua", LFS_O_RDONLY) == LFS_ERR_OK) {
    //    luat_print("reading main.lua--------------------\n");
    //    char *buf = luat_heap_calloc(file.size+1);
    //    LFS_FileRead(&file, buf, file.size);
    //    LFS_FileClose(&file);
    //    luat_print("run main.lua-----------------------\n");
    //    re = luaL_dostring(L, buf);
    //    luat_heap_free(buf);
    //    luat_print("done main.lua-------------------------\n");
    //}
    //else {
      re = luaL_dostring(L, "print(_VERSION)");
    //    luat_print("/lua/main.lua not found!!! run default lua string\n");
    //    re = luaL_dostring(L, "print(\"test1=====\") local a = 1\n local b=2\nprint(_G)\nprint(a+b)\nprint(sys)\nprint(_VERSION)");
    //    re = luaL_dostring(L, "print(\"test2=====\") local ab=1 \nprint(rtos.get_version()) print(rtos.get_memory_free())");
    //    re = luaL_dostring(L, "print(\"test3=====\") print(a - 1)");
    //    re = luaL_dostring(L, "print(\"test4=====\") print(rtos.get_memory_free()) collectgarbage(\"collect\") print(rtos.get_memory_free())");
    //    re = luaL_dostring(L, "print(\"test5=====\") print(rtos.timer_start(1, 3000)) print(rtos.receive(5000)) print(\"timer_get?\")");
    //    re = luaL_dostring(L, "print(\"test6=====\") local f = io.open(\"abc.log\", \"w\") print(f)");
    //    re = luaL_dostring(L, "print(_VERSION) timer.mdelay(2000) print(_VERSION)");
    //}
    
    if (re) {
        luat_print("luaL_dostring  return re != 0\n");
        luat_print(lua_tostring(L, -1));
    }

    //lua_pushboolean(L, 1);
    //luat_print("luat_pmain_complete\n");
    lua_pushboolean(L, 1);  /* signal no errors */
    return 1;
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}


/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message("LUAT", msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

int luat_main (int argc, char **argv) {
  int status, result;
  lua_State *L = lua_newstate(luat_heap_alloc, NULL);
  if (L == NULL) {
    l_message(argv[0], "cannot create state: not enough memory");
    return 1;
  }
  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
  lua_pushinteger(L, argc);  /* 1st argument */
  lua_pushlightuserdata(L, argv); /* 2nd argument */
  status = lua_pcall(L, 2, 1, 0);  /* do the call */
  result = lua_toboolean(L, -1);  /* get result */
  report(L, status);
  lua_close(L);
  return (result && status == LUA_OK) ? 0 : 2;
}

#ifdef LUAT_MAIN
int main(int argc, char *argv[], char *envp[] ) {
    return luat_main(argc, argv, envp);
}
#endif